import numpy as np
import scipy.io
from pyTFM.TFM_functions import strain_energy_points, contractillity
from pyTFM.grid_setup_solids_py import interpolation, prepare_forces, grid_setup, FEM_simulation
from skimage import io
from skimage.morphology import dilation
from skimage.morphology import disk

# %% setting parameters and initialize variables
folder = "C:/Users/Balland/Desktop/_collaborations/Vladimir Misiak/40micron_lefthalf_stim"
noCells = 46
ps1 = 0.162  # pixel size of the image of the beads in Âµm
ps2 = 1.296  # pixel size of of the deformation field
print("Outputfolder: " + folder)
for cell in np.arange(11, noCells + 1):
    if cell <= 9:
        foldercellpath = folder + "/tissue0" + str(cell)
    else:
        foldercellpath = folder + "/tissue" + str(cell)
    mat = scipy.io.loadmat(foldercellpath + "/Allresults2.mat")

    u_all = mat["Dx"]
    v_all = mat["Dy"]
    tx_all = mat["Tx"]
    ty_all = mat["Ty"]

    sigma_x_all = np.zeros(shape=np.shape(tx_all))
    sigma_y_all = np.zeros(shape=np.shape(tx_all))
    sigma_xy_all = np.zeros(shape=np.shape(tx_all))
    sigma_yx_all = np.zeros(shape=np.shape(tx_all))

    noFrames = np.shape(u_all)[2]

    strain_energy_all = np.zeros(noFrames)

    # mask_all = mat2["mask"] > 0
    for t in np.arange(0, noFrames):
        u = u_all[:, :, t] / (ps1 * 1e-6)  # u and v are given in m/s but MSM script expects pixel/s
        v = v_all[:, :, t] / (ps1 * 1e-6)
        tx = tx_all[:, :, t]
        ty = ty_all[:, :, t]

        # prepare masks
        mask_original = io.imread(folder + '/mask.tif')
        #
        mask = interpolation(mask_original, dims=u.shape)
        #
        footprint = disk(12)
        mask_dilated = dilation(mask, footprint)
        mask_FEM = dilation(mask, footprint)

        # fig = plt.figure()
        # im = plt.imshow(tx, cmap=plt.get_cmap('hot'), interpolation='bilinear', extent=extent, vmin=-800, vmax=1300)
        # plt.colorbar(im)
        # calculating strain_energy and contractility

        # Strain energy:
        # Calculating a map of strain energy
        energy_points = strain_energy_points(u, v, tx, ty, ps1, ps2)  # J/pixel
        # Calculating the total strain energy in the area of the cells
        strain_energy_all[t] = np.sum(energy_points[mask_dilated])  # 1.92*10**-13 J

        # Contractillity
        contractile_force, proj_x, proj_y, center = contractillity(tx, ty, ps2, mask_dilated)  # 2.01*10**-6 N

        # calculating stresses
        # first mask: The area used for Finite Elements Methods.
        # should encircle all forces generated by the cell colony
        mask_FEM = mask_dilated

        # second mask: The area of the cells. Average stresses and other values are calculated only
        # on the actual area of the cell, represented by this mask.
        mask_cells = mask_dilated

        # converting tractions (forces per surface area) to forces
        # and correcting imbalanced forces and torques

        fx, fy = prepare_forces(tx, ty, ps2, mask_FEM)
        f = np.sqrt(np.power(fx, 2) + np.power(fy, 2))

        # construct FEM grid
        nodes, elements, loads, mats = grid_setup(mask_FEM, -fx, -fy, sigma=0.5)
        # # performing FEM analysis
        UG_sol, stress_tensor = FEM_simulation(nodes, elements, loads, mats, mask_FEM, verbose=True)
        # fig1 = plt.figure()
        # plt.imshow(stress_tensor[:,:,0,0])
        # fig2 = plt.figure()
        # plt.imshow(stress_tensor[:,:,1,1])
        # #
        sigma_x_all[:, :, t] = stress_tensor[:, :, 0, 0]
        sigma_y_all[:, :, t] = stress_tensor[:, :, 1, 1]
        sigma_xy_all[:, :, t] = stress_tensor[:, :, 0, 1]
        sigma_yx_all[:, :, t] = stress_tensor[:, :, 1, 0]

        # extent = [0, 112*0.108*8, 0, 112*0.108*8]
        #
        # fig = plt.figure()
        # im = plt.imshow(stress_tensor[:, :, 0, 0], cmap=plt.get_cmap('hot'), interpolation='bilinear', extent=extent, vmin=0, vmax=1e-8)
        # plt.colorbar(im)
        # plt.show()
        # #fig.savefig(sigmaxpath)
        # #plt.close(fig)
        #
        # fig = plt.figure()
        # im = plt.imshow(stress_tensor[:, :, 1, 1], cmap=plt.get_cmap('hot'), interpolation='bilinear', extent=extent, vmin=0, vmax=1e-8)
        # plt.colorbar(im)
        # plt.show()
        # #fig.savefig(sigmaypath)
        # #plt.close(fig)
    np.save(foldercellpath + "/stressmaps.npy", [sigma_x_all, sigma_y_all, sigma_xy_all, sigma_yx_all])
